在编写代码的过程中，相信大家肯定遇到过这样的情况：代码能够编译通过，没有语法错误，但是运行结果却不对，反复检查了很多遍，依然不知道哪里出了问题。这个时候，就需要调试程序了。

Linux GDB调试教程封面

即使对于一个经验非常丰富的程序员，在编写程序的时候也避免不了出错。程序中的语法错误通常可以在翻译阶段就能被诊断出来，但逻辑错误却很难被发现和纠正，比如在解决问题时使用了错误或者不完备的思路。在这种情况下，调试可能是唯一的救命稻草。通过设置适当的断点，你可以观察结果并和预期的结果进行比较以缩小问题代码的范围，并最终发现问题所在。

这套简明版的 Linux GDB 调试教程从实用的角度出发，结合一段简单的C语言代码，讲解了七个最常用的 GDB 选项。在该教程中，我将手把手教大家如何跟踪程序的运行过程，大家学习完本教程后，调试简单的C语言程序不再是难题。
什么是调试？
所谓调试（Debug），就是让代码一步一步慢慢执行，跟踪程序的运行过程。比如，可以让程序停在某个地方，查看当前所有变量的值，或者内存中的数据；也可以让程序一次只执行一条或者几条语句，看看程序到底执行了哪些代码。

在调试的过程中，我们可以监控程序的每一个细节，包括变量的值、函数的调用过程、内存中数据、线程的调度等，从而发现隐藏的错误或者低效的代码。

编译器可以发现程序的语法错误，调试可以发现程序的逻辑错误。所谓逻辑错误，是指代码思路或者设计上的缺陷。

对于初学者来说，学习调试也可以增加编程的功力，它能让我们更加了解自己自己的程序，比如变量是什么时候赋值的、内存是什么时候分配的，从而弥补学习的纰漏。

调试是每个程序员必须掌握的技能，没有选择的余地！

调试需要借助专业的辅助软件——调试器（Debugger）。现在主流C/C++调试器有下面几种：
1) Remote Debugger
Remote Debugger 是 VC/VS 自带的调试器，与整个IDE无缝衔接，使用非常方便，初学者建议使用该调试器，本教程也以 VS2010 为例讲解调试技巧。
2) WinDbg
大名鼎鼎的 Windows 下的调试器，它的功能甚至超越了 Remote Debugger，它还有一个命令行版本（cdb.exe），但是这个命令行版本的调试器指令比较复杂，不建议初学者使用。
3) LLDB
XCode 自带的调试器，Mac OS X 下开发必备调试器。
4) GDB
Linux 下使用最多的一款调试器，也有 Windows 的移植版。
关于 GDB
GDB 是 Linux 下的 C/C++ 程序调试工具，它开源免费，功能强大，但是命令众多，所以需要一段时间的学习。

GDB调试器图标
图：GDB 调试器图标

正如从事 Windows C/C++ 开发的一定要熟悉 Visual Studio、从事 Java 开发的要熟悉 Eclipse 或 IntelliJ IDEA、从事 Android 开发的要熟悉 Android Studio、从事 iOS 开发的要熟悉 XCode 一样，从事 Linux C/C++ 开发要熟悉 GDB。

虽然 Linux 系统下读者编写 C/C++ 代码的 IDE 可以自由选择，但是调试生成的 C/C++ 程序一定是直接或者间接使用 GDB。可以毫不夸张地说，我所做那些 C/C++ 项目的开发和调试包括故障排查都是利用 GDB 完成的，调试是开发流程中一个非常重要的环节，因此对于从事 Linux C/C++ 的开发人员熟练使用 GDB 调试是一项基本要求。

“工欲善其事、必先利其器”，作为一名合格的软件开发者，至少得熟悉一种软件开发工具和调试器， 而对于 Linux C/C++ 后台开发，舍 GDB 其谁。
GDB 入门教程
本教程以下面的代码为例，在 Linux 系统下来讲解 GBD 的调试流程：
```c
int main (void)
{
    unsigned long long int n, sum;

    n = 1;
    sum = 0;

    while (n <= 100)
    {
        sum = sum + n;
        n = n + 1;
    }

    return 0;
}
```

将代码保存到 ~/demo/main.c，~表示当前用户的主目录，也即 home 目录。

首先我们使用 GCC 来编译 main.c，编译的时候使用-g选项，它的目的是向可执行程序中加入调试信息，包括源代码、符号表等，GDB 需要这些额外的信息来完成调试工作。

此外还建议关闭编译器的程序优化选项。编译器的程序优化选项一般有五个级别，从 O0 ~ O4， O0 表示不优化，从 O1 ~ O4 优化级别越来越高，O4 最高。这样做的目的是为了调试的时候，符号文件显示的调试变量等能与源代码完全对应起来。

使用 GCC 编译源文件：
$ cd demo
$ gcc main.c -o main.out -g
打开 demo 文件夹，发现多了一个 mian.out，说明编译成功。
1) 启动 GDB 调试器
接下来启动 GDB 并调试 main.out：
$ gdb main.out -silent
Reading symbols from /home/mozhiyan/demo/main.out...done.
选项-silent用于屏蔽 GDB 的前导信息，否则它会在屏幕上打印一堆免责条款。

启动 GDB 后，它输出的信息表明已经读入了 mian.out 的符号表。接下来，GDB 会显示自己的提示符(gbd)，提示并等待你输入调试命令。
2) gdb -b 选项：设置断点
调试一个程序的时候，应该在我们关注的地方，或者在故障点的前边设置一个断点（Breakpoint），让程序执行到这里停下来，这样我们就可以慢慢地用别的调试命令进行观察。

在 GDB 中，设置断点的方法很多，包括在指定的内存地址处设置断点、在源代码的某一行设置断点，或者在某个函数的入口处设置断点，等等。设置断点的命令是b或者break，在这里我 们是将 main 函数的入口处作为断点：
(gdb) b main
Breakpoint 1 at 0x4004f4: file main.c, line 5.
b 命令在执行后返回了断点的具体信息，也就是说，断点（main 函数的入口位置）的内存地址为 0x4004f4，对应于源文件的第 5 行（也就是说，main 函数位于源文件的第 5 行）。

如果我们用内存地址的方式来设置这个断点，则可以是：
b * 0x4004f4

星号*意味着是以内存地址作为断点的。

如果用源代码行的形式设置这个断点，则可以是
b 5

3) gdb -r 选项：执行程序
一旦设置了断点，下一步就是用r或者run命令执行被调试的程序，执行后会自动在第一个断点处停下来：
Starting program: /home/mozhiyan/demo/main.out
[New Thread 1500.0x1e34]
[New Thread 1500.0x2fb8]

Thread 1 hit Breakpoint 1, main () at main.c:5
5     n = 1;
在运行了被调试的程序后，GDB 的输出信息显示程序己经启动，下一个将要执行的语句是第 5 行的n = 1;。

注意，这条语句并没有执行，而仅仅是告诉你，再继续执行程序的话，执行的语句会是它。
4) gdb -p 选项：打印变量的值
在当前位置，变量 n 和 sum 己经分配，但并没有开始赋值。此时，这两个变量的值会是多少呢？我们可以使用p或者print命令来分别显示：
(gdb) p n
$1 = 24
(gdb) p sum
$2 = 140737488347344
GDB 的 p 命令用于打印一个表达式的值，在这里是表达式 n 和 sum。

GDB 先计算表达式的值，并把它保存在一个存储区中，存储区的名字用$外加数字来表示，并且这个数字会随着调试过程的进行而不断递增（这意味着存储区也是不断开辟的）。以上，第一个 p 命令执行后，GDB 的回应是$1 = 16，意思是表达式 n 的值保存在 $1 中，其内容为 16。

注意，在你的计算机上，变量 n 和 sum 的当前值可能和这里显示的不同。这很好理解，内存是反复使用的，当一个程序终止后，它占用的内存会分配给其他程序使用；当一个变量不再使用后，它占用的内存也会重新分配，并成为另一个变量。因为变量 n 和 sum 刚刚分配，还没有往里面保存任何数值，故它们的内容是随机的，是其他程序或者变量用过的垃圾值。

顺便说一下，既然 $1 是 GDB 用于保存计算结果的内部存储区的名字，那么我们也可以用 p 命令来打印它：
(gdb) p $1
$3 = 24
5) gdb -n 选项：单步调试
下面，我们将通过单步执行程序，来看一看变量 n 和 sum 赋值后的值。调试命令n或者next用于继续执行源文件中的下一行。
(gdb) n
6     sum = 0;
执行 n 命令后，实际执行的是第 5 行n = 1;，GDB 显示下一个即将执行的源代码行，也就是第 6 行的sum = 0;。

因为此时己经往变量 n 写入了 1，所以我们可继续用 p 命令来观察它现在的存储值：
(gdb) p n
$4 = 1
显然，经赋值后，变量 n 的值己经变成 1。

继续执行下一条指令，实际执行的是第 6 行sum = 0。执行后，GDB 停下并显示下一条即将执行的源代码行，也即第 8 行的while (n <= 100)，第 7 行为空行，所以直接跳过了：
(gdb) n
8     while (n <= 100)
刚才执行的语句是往变量 sum 保存数值 0，故我们可以再次用 p 命令来观察变量 sum 现在的存储值，可发现它己经变成 0：
(gdb) p sum
$5 = 0
继续用 n 命令执行下一个源代码行，则将计算 while 语句的控制表达式，并根据该表达式的值决定是否进入循环体，执行后 GDB  显示下一条即将执行的源代码行是第 10 行：
(gdb) n
10    sum = sum + n;
进入循环体之后，我们想再看看变量 n 和 sum 的当前值。但这次使用 p 命令的方法不一样，这次是用花括号将表达式 n 和 sum 围住以形成一个集合。GDB 允许用这种方式来一次性地打印多个表达式的值：
(gdb) p {n, sum}
$6 = {1, 0}
显然，变量 n 和 sum 此时的值依然分别为 1 和 0。

继续用 n 命令执行第 10 行，执行后 GDB 停留在即将执行的第 11 行：
(gdb) n
11    n = n + 1;
注意，第 10 行己经执行完毕，但第 11 行还没有执行。猜猜看，变量 n 和 sum 此时的值是多少？猜测之后，用 p 命令看看结果是否如你所想：
(gdb) p {n, sum}
$7 = {1, 1}
继续用 n 命令执行下一个源代码行，这将执行第 11 行的n = n + 1;，执行后控制又回到了循环的起始处，也即第 8 行：
(gdb) n
8     while (n <= 100)
此时，变量 n 和 sum 的值各自会是多少？使用 p 命令打印一下就知道了：
(gdb) p {n, sum}
$8 = {2, 1}
因为现在处于一个循环体内，如果继续用 n 命令往下执行，则其过程与前面相比大同小异。前面己经循环过一次，本次循环完整的调试过程如下：
(gdb) n
10    sum = sum + n;
(gdb) n
11    n = n + 1;
(gdb) n
8    while (n <= 100)
(gdb) p {n, sum}
$9 = {3, 3}
显然，第二次循环过后，变量 n 的值为 3，变量 sum 的值也是 3。

你可能己经发现了，我们现在进退维谷：如果继续用 n 命令执行，则将陷入循环，直到变量 n 的值等于 101。好在这也算不上什么大的问题，我们可以在循环语句的后面设置断点，然后命令程序一直执行，直至到达这个断点。
6) gdb -l 选项：列出源文件内容
为了搞清楚 while 语句的下一条语句的行号，我们需要列出源文件的内容，这需要使用l或者list命令：
```bash
(gdb) l
3     unsigned long long int n, sum;
4
5     n = 1;
6     sum = 0;
7
8     while (n <= 100)
9     {
10        sum = sum + n;
11        n = n + 1;
12    }
```

l 命令默认每次显示 10 行源代码，但我们关心的那一行显然还没有出来。为此，可继续使用 l 命令来显示后面的行：
(gdb) l
13
14        return 0;
15    }
好了，我们己经知道 while 语句之后是 return 语句，它的行号是 14，现在就可以用 b 命令设置一个新的断点：
(gdb) b 14
Breakpoint 2 at 0x40051a: file main.c, line 14.
7) gdb -c 选项：继续执行程序
现在，可以用一个新的命令c或者continue来持续执行程序，直至遇到断点或者程序结束。因为己经设置断点，故程序将持续执行，在第 14 行处停下：
(gdb) c
Continuing.

Breakpoint 2, main () at main.c:14
14     return 0;
非常好，既然己经退出了 while 循环，说明累加过程己经成功结束，变量 sum 的值就是累加结果。我们来看看它到底是多少：
(gdb) p {n, sum}
$10 = {101, 5050}
显然，变量 n 的当前值是 101，变量 sum 的当前值是 5050，和数学计算的结果一模 一样。
8) gdb -q 选项：退出调试
本次调试即将结束，我们可以先用 c 命令让程序“跑完全程”，然后再用q或者quit结束本次调试工作，这将使得调试器 GDB 结束运行并返回到操作系统：
(gdb) c
Continuing.
[Inferior 1 (process 2814) exited normally]
(gdb) q
[c.biancheng.net demo]$
好了，GDB 调试过程到此结束。
总结
GDB 是非常强大的工具，它的用法可以写一本厚厚的书，上述 GDB 调试教程虽然是蜻蜓点水、走马观花，但对于初学者来说已经足够了，大家应该能够发现 99% 的逻辑错误了。
精美而实用的网站，分享优质编程教程，帮助编程初学者。千锤百炼，只为大作；精益求精，句句斟酌；这种教程，看一眼就倾心。